package com.github.alexishuf.fastersparql.grep.cli;

import com.github.alexishuf.fastersparql.grep.AppException;
import com.github.alexishuf.fastersparql.grep.FileChunk;
import com.github.alexishuf.fastersparql.grep.FileOutputChunk;
import com.github.alexishuf.fastersparql.grep.FileScanner;
import com.github.alexishuf.fastersparql.model.rope.SegmentRope;
import com.github.alexishuf.fastersparql.util.concurrent.LIFOPool;
import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
import picocli.CommandLine.*;
import picocli.CommandLine.Model.CommandSpec;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.channels.WritableByteChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.locks.ReentrantLock;

import static java.lang.Integer.MAX_VALUE;

@Command(name = "journal", aliases = {"j"},
         description = "Filters lanes and lines of a DebugJournal dump file, " +
                       "outputting only lanes and lines which mat at least one of the given keys")
public class GrepJournal implements Callable<Void> {
    private @Spec CommandSpec commandSpec;
    private @Mixin LogOptions logOptions;
    private @Mixin FileScannerOptions scannerOpts;
    private @Mixin OutputOptions outputOptions;

    @Parameters(arity = "1", paramLabel = "FILE",
                description = "Path to a .journal file generated by DebugJournal.dump().")
    private Path journalFile;

    @Parameters(arity = "1..*", paramLabel = "KEYS",
                description = "Strings against which exact matches will be searched " +
                              "within lanes of the DebugJournal dump file")
    private String[] exactMatchStrings = new String[0];

    private byte[][] exactMatchU8;
    private final ReentrantLock lock = new ReentrantLock();
    private int laneCount, laneWidth, writtenChunks;
    private final BitSet selLanes = new BitSet(512);
    private WritableByteChannel filteredDst;
    private @MonotonicNonNull LIFOPool<FilteredChunk> filteredPool;
    private final ArrayList<FilteredChunk> filteredChunks = new ArrayList<>();

    @Override public Void call() throws Exception {
        selLanes.clear();
        selLanes.set(0);
        laneCount = 0;
        writtenChunks = 0;
        laneWidth = MAX_VALUE;
        if (filteredPool == null) {
            filteredPool = new LIFOPool<>(FilteredChunk.class,
                    "FilteredChunkPool",
                    2*scannerOpts.maxTotalChunks(),
                    scannerOpts.chunkBytes
            );
        }
        if (Files.notExists(journalFile))
            raiseParamException("File "+journalFile+" does not exist");
        exactMatchU8 = new byte[exactMatchStrings.length][];
        for (int i = 0; i < exactMatchStrings.length; i++) {
            String s = exactMatchStrings[i];
            if (s == null || s.isEmpty())
                raiseParamException("KEYS cannot contain empty strings");
            exactMatchU8[i] = s.getBytes(StandardCharsets.UTF_8);
        }
        try (var ch = Files.newByteChannel(journalFile, StandardOpenOption.READ);
             var ignored = filteredDst = outputOptions.open();
             var scanner = scannerOpts.createScanner()) {
            scanner.scan(ch.position(0), this::selectLanes);
            scanner.scan(ch.position(0), this::filter);
        } catch (FileNotFoundException|NoSuchFileException e) {
            throw new AppException("File "+journalFile+" does not exist (as a file)");
        } catch (IOException e) {
            throw new AppException("Could not read from "+journalFile);
        } catch (ExecutionException e) {
            Throwable c = e.getCause();
            if (c instanceof FileNotFoundException || c instanceof NoSuchFileException)
                throw new AppException("File "+journalFile+" does not exist (as a file)");
            else if (c instanceof IOException)
                throw new AppException("Could not read "+journalFile+": "+e.getMessage());
            else
                throw e;
        }
        return null;
    }

    private void raiseParamException(String msg) {
        throw new ParameterException(commandSpec.commandLine(), msg);
    }

    private boolean hasMatch(SegmentRope chunk, int begin, int end) {
        for (byte[] u8 : exactMatchU8) {
            if (chunk.skipUntil(begin, end, u8) < end) return true;
        }
        return false;
    }

    private void selectLanes(SegmentRope chunk) {
        int laneCount = -1;
        for (int begin=0, lane=0, eol, chunkLen = chunk.len; begin < chunkLen; begin=eol+1) {
            eol = chunk.skipUntil(begin, chunkLen, '|', '\n');
            if (!selLanes.get(lane)) {
                if (hasMatch(chunk, begin, eol)) {
                    while (!lock.tryLock()) Thread.onSpinWait(); // too short to park()
                    selLanes.set(lane);
                    lock.unlock();
                }
            }
            if (lane > 0 && selLanes.get(lane)) {
                int width = eol - begin;
                if (width < laneWidth) {
                    while (!lock.tryLock()) Thread.onSpinWait();
                    laneWidth = width;
                    lock.unlock();
                }
            }
            ++lane;
            if (eol < chunkLen && chunk.get(eol) == '\n') {
                laneCount = Math.max(laneCount, lane);
                lane = 0;
            }
        }
        while (!lock.tryLock()) Thread.onSpinWait(); // too short to park()
        this.laneCount = Math.max(this.laneCount, laneCount);
        lock.unlock();
        if (selLanes.cardinality() == this.laneCount)
            throw FileScanner.StopScan.INSTANCE; // all lanes are selected
    }

    private static final class FilteredChunk extends FileOutputChunk {
        public int seq;

        public FilteredChunk(int capacity, int seq) {
            super(capacity);
            this.seq = seq;
        }
    }

    private FilteredChunk allocFilteredChunk(int bytes, int seq) {
        var chunk = filteredPool.get();
        if (chunk != null) {
            chunk.rope.clear();
            chunk.seq = seq;
            return chunk;
        }
        return new FilteredChunk(bytes, seq);
    }

    private void filter(FileChunk chunk) throws AppException {
        var f = allocFilteredChunk(chunk.len, chunk.chunkNumber);
        int revertTo = f.rope.len;
        for (int lane=0, begin=0, chunkLen=chunk.len, eol; begin < chunkLen; begin=eol+1) {
            eol = chunk.skipUntil(begin, chunk.len, '|', '\n');
            if (selLanes.get(lane)) {
                if (lane == 0 || hasMatch(chunk, begin, eol)) {
                    if (lane > 0)
                        revertTo = -1;
                    f.rope.append(chunk, begin, eol);
                } else {
                    f.rope.repeat((byte)' ', laneWidth);
                }
                f.rope.append('|');
            }
            boolean newline = false;
            if (eol >= chunkLen || (newline = chunk.get(eol) == '\n')) {
                lane = 0;
                if (newline) {
                    if (revertTo >= 0)
                        f.rope.len = revertTo;
                    else
                        revertTo = f.rope.append('\n').len;
                }
            } else {
                ++lane;
            }
        }
        lock.lock();
        try { // saves FilteredChunk and writes chunks that can be written
            filteredChunks.add(f);
            while (true) {
                FilteredChunk next = null;
                for (int i = 0, n = filteredChunks.size(); i < n && next == null; i++) {
                    if (filteredChunks.get(i).seq == writtenChunks)
                        next = filteredChunks.remove(i);
                }
                if (next == null)
                    break; // next chunk is not ready to write yet
                lock.unlock(); // will perform IO
                try {
                    filteredDst.write(next.buffer());
                } catch (IOException e) {
                    throw new AppException("Could not write to "+outputOptions+": "+e);
                } finally {
                    filteredPool.offer(f); // allow reuse by allocFilteredChunk()
                    lock.lock();
                    ++writtenChunks;
                }
            }
        } finally {
            lock.unlock();
        }
    }

}
